From df24f173c7dde3a1b3631b50366757ba5853a3ea Mon Sep 17 00:00:00 2001
From: Greg Sheremeta <gshereme@redhat.com>
Date: Sat, 22 Feb 2014 17:02:34 -0500
Subject: [PATCH] fixed buffering bug described in issue #44 - backport to
 0.3.18

---
 pithos/data/ui/PithosWindow.ui |  2 +-
 pithos/pandora/fake.py         |  9 ++++++---
 pithos/pithos.py               | 31 ++++++++++++++++++++++++-------
 3 files changed, 31 insertions(+), 11 deletions(-)

diff --git a/pithos/data/ui/PithosWindow.ui b/pithos/data/ui/PithosWindow.ui
index 11c63df..5ba2336 100644
--- a/pithos/data/ui/PithosWindow.ui
+++ b/pithos/data/ui/PithosWindow.ui
@@ -24,7 +24,7 @@
                 <property name="visible">True</property>
                 <property name="label" translatable="yes">Play</property>
                 <property name="stock_id">gtk-media-play</property>
-                <signal name="clicked" handler="playpause"/>
+                <signal name="clicked" handler="user_playpause"/>
               </object>
               <packing>
                 <property name="expand">False</property>
diff --git a/pithos/pandora/fake.py b/pithos/pandora/fake.py
index 9d93a70..e770682 100644
--- a/pithos/pandora/fake.py
+++ b/pithos/pandora/fake.py
@@ -18,6 +18,8 @@
 import gtk
 import logging
 
+TEST_FILE = "http://pithos.github.io/testfile.aac"
+
 class FakePandora(Pandora):
     def __init__(self):
         super(FakePandora, self).__init__()
@@ -105,18 +107,19 @@ def get_station_by_token(self, token):
 
     def makeFakeSong(self, stationId):
         c = self.count()
+        audio_url = TEST_FILE + '?val='+'0'*48
         return {
             'albumName':"AlbumName",
             'artistName':"ArtistName",
             'audioUrlMap': {
                 'highQuality': {
-                    'audioUrl': 'http://pithos.github.io/testfile.aac?val='+'0'*48
+                    'audioUrl': audio_url
                 },
                 'mediumQuality': {
-                    'audioUrl': 'http://pithos.github.io/testfile.aac?val='+'0'*48
+                    'audioUrl': audio_url
                 },
                 'lowQuality': {
-                    'audioUrl': 'http://pithos.github.io/testfile.aac?val='+'0'*48
+                    'audioUrl': audio_url
                 },
             },
             'trackGain':0,
diff --git a/pithos/pithos.py b/pithos/pithos.py
index 1897368..45eec24 100755
--- a/pithos/pithos.py
+++ b/pithos/pithos.py
@@ -418,7 +418,8 @@ def start_song(self, song_index):
             return self.next_song()
 
         logging.info("Starting song: index = %i"%(song_index))
-        self.buffer_percent = 100
+        self.buffer_percent = 0
+        self.song_started = False
         self.player.set_property("uri", self.current_song.audioUrl)
         self.play()
         self.playcount += 1
@@ -436,13 +437,14 @@ def next_song(self, *ignore):
 
     def user_play(self, *ignore):
         self.play()
+        self.song_started = True
         self.emit('user-changed-play-state', True)
 
     def play(self):
         if not self.playing:
             self.playing = True
-            self.player.set_state(gst.STATE_PLAYING)
-            gobject.timeout_add_seconds(1, self.update_song_row)
+        self.player.set_state(gst.STATE_PLAYING)
+        gobject.timeout_add_seconds(1, self.update_song_row)
         self.playpause_button.set_stock_id(gtk.STOCK_MEDIA_PAUSE)
         self.update_song_row()
         self.emit('play-state-changed', True)
@@ -474,6 +476,9 @@ def stop(self):
         self.player.set_state(gst.STATE_NULL)
         self.emit('play-state-changed', False)
 
+    def user_playpause(self, *ignore):
+        self.playpause_notify()
+        
     def playpause(self, *ignore):
         if self.playing:
             self.pause()
@@ -597,13 +602,23 @@ def on_gst_error(self, bus, message):
         self.next_song()
 
     def on_gst_buffering(self, bus, message):
+        # per GST documentation:
+        # Note that applications should keep/set the pipeline in the PAUSED state when a BUFFERING
+        # message is received with a buffer percent value < 100 and set the pipeline back to PLAYING
+        # state when a BUFFERING message with a value of 100 percent is received.
+        
+        # 100% doesn't mean the entire song is downloaded, but it does mean that it's safe to play.
+        # trying to play before 100% will cause stuttering.
         percent = message.parse_buffering()
         self.buffer_percent = percent
-        #if percent < 100:
-            #self.player.set_state(gst.STATE_PAUSED)
-        #elif self.playing:
-            #self.player.set_state(gst.STATE_PLAYING)
+        if percent < 100:
+            self.player.set_state(gst.STATE_PAUSED)
+        else:
+            if self.playing:
+                self.play()
+                self.song_started = True
         self.update_song_row()
+        logging.debug("Buffering (%i%%)"%self.buffer_percent)
 
     def set_volume_cb(self, volume):
         # Convert to the cubic scale that the volume slider uses
@@ -637,6 +652,8 @@ def song_text(self, song):
                 dur_int = self.player.query_duration(self.time_format, None)[0]
                 dur_str = self.format_time(dur_int)
                 pos_int = self.player.query_position(self.time_format, None)[0]
+                if not self.song_started:
+                    pos_int = 0
                 pos_str = self.format_time(pos_int)
                 msg.append("%s / %s" %(pos_str, dur_str))
                 if not self.playing:
-- 
1.8.5.5

